# 复习

## JVM架构模型

首先是Class File（即类文件），然后使用类加载子系统将.class文件加载进内存空间。

然后执行引擎执行.class字节码文件，进入运行时数据区。

## 类加载子系统

类加载子系统主要是将`.class`文件加载进内存空间，至于能否运行取决于执行引擎`(Execution Engine)`

它主要包括三部分

- **加载**：将`.class`文件加载进内存空间，在方法区生成一个`java.lang.Class`的信息，根据字节码获取字节流信息，加载进内存空间。
  - **引导类加载器（也叫启动类加载器）**（`Bootstrap ClassLoader`，使用C语言编写）
  - **自定义类加载器（所有继承自`ClassLoader`的类，使用Java语言编写）**
    - 扩展类加载器（`Extension ClassLoader`）（Java中的实现为`Launcher$ExtClassLoader`类，其父加载器是`Bootstrap ClassLoader`）
    - 系统类加载器（`System ClassLoader`）（Java中的实现为`Launcher$AppClassLoader`类，其父加载器是`Extension ClassLoader`）

- **链接**
  - **验证：**验证加载进内存的字节流是否符合虚拟机要求，保证类加载的正确性。
  - **准备：**为类变量分配内存并设置该变量的默认值，即零值，不包括final修饰的static
  - **解析：**将常量池中的符号引用转变为直接引用的过程，创建并初始化虚方法表
- **初始化**
  - 初始化就是类的`<clinit>`方法的执行
  - 这个方法是Java自动生成，会将所有的静态初始化或者静态代码块全部放在这个方法里面，进行显式地赋值。

### 什么是双亲委派机制

- 如果一个类加载器收到了类加载的请求，它首先并不会自己去加载，而是把这个请求委托给父类去加载
- 如果父类加载器还存在父类加载器，则继续向上请求，依次递归，直到到最顶层的启动类加载器
- 如果父类加载器可以完成加载任务，则由父类加载，加载完成后返回，如果父类不能加载，子加载器才会尝试自己去加载。

Java程序对类的使用方式分为：主动使用和被动使用，被动使用不会导致类的初始化

## 运行时数据区

HotSpot主要包括五部分，其他虚拟机不一定包含所有的五部分，不同的虚拟机架构也不同。

- **程序计数器（PC计数器）**
- **虚拟机栈**
- **本地方法栈**
- **堆**
- **方法区**

其中，**程序计数器、虚拟机栈、本地方法栈**是每个线程都有一份的，而**堆和方法区**是所有线程共享的。

## 程序计数器

用来存储**下一条指令的地址**，由**执行引擎**读取下一条指令。

不会出现异常和垃圾回收。

生命周期和线程的生命周期一致。

## 虚拟机栈

**栈是运行时单位，堆是存储时的单位。**

JAVA指令都是根据栈的指令来设计的。指令简单，跨平台性好，但是执行相同的运算需要更多的指令。

另外一种是基于寄存器的指令系统，与硬件的耦合性更高，指令更复杂，但是执行速度更快一些。

**是什么**：每个线程在创建时都会创建一个虚拟机栈，其中保存的是一个个的栈帧，对应一个个的方法。

**生命周期**：生命周期和线程的生命周期一致。

**作用**：主要保存方法运行过程中的局部变量、部分结果、并参与方法的返回和调用。

**异常**：StackOverflowError异常和OutOfMemoryError异常。

**没有垃圾回收机制。**

**设置栈的大小**：使用-Xss参数来设置栈空间的大小。

栈中存储的是一个个的栈帧，一个栈帧从入栈到出栈的过程，意味着一个方法从开始执行到执行完毕的过程。

方法有两种结束方式：①正常执行方法，正常退出②方法执行中出现未捕获的异常，以抛出异常的方式结束。

## 栈帧的内部结构

每个栈帧中都保存着：

- 局部变量表
- 操作数栈
- 动态链接
- 方法返回地址
- 一些附加信息

## 局部变量表

局部变量表的大小在**编译期**就已经确定了，保存的就是方法中的**局部变量**，包括**方法参数**、**内部局部变量**、如果是类的实例方法，即非static方法，内部还有一个**this变量**，索引是0，即最先放入局部变量表中。

局部变量表是一个数组，单位是一个个的`Slot(槽)`，32位及以下的数据占据一个槽，而像long和double64位类型的数据占用两个Slot，引用类型的数据占用一个槽。

栈帧中的局部变量表是可以重复利用的，如果一个参数过了其作用域，则其占据的槽可以后面的参数重复利用，以达到节省资源的目的。

静态变量和局部变量的区别：

静态变量会经过两次初始化：①在类加载子系统中的**链接**的**准备**阶段，会初始化为默认值②在类加载子系统的**初始化**阶段会执行`<clinit>`方法，对静态变量显式初始化。

而局部变量则不会被系统初始化，要使用的话必须自己进行初始化。

> **局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。**

## 操作数栈

- 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据。
- 主要用于**保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。**
- 当一个方法刚开始执行的时候，一个新的栈帧就被创建出来了，这个方法的**操作数栈是空**的。
- 操作数栈是使用数组实现的，大小在**编译期间**就已经确定了。
- 栈中占用的空间和局部变量表占用的空间一致，32位一个，64位两个。
- **如果被调用方法有返回值的话，返回值会被压入当前栈帧的操作数栈中。**
- Java虚拟机的**解释引擎是基于栈的执行引擎，其中栈就是操作数栈。**

## 动态链接（指向运行时常量池的方法引用）



## 方法的调用：解析和分派

